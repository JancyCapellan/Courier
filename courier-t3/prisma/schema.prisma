// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  // previewFeatures = ["interactiveTransactions"]
}

// generator erd {
//   provider = "prisma-erd-generator"
//   includeRelationFromFields = true
// }
//TODO: change database schema to non public, there may be issues with it as public.
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String                @id @default(cuid())
  // name          String? // prisma adapter field
  emailVerified     DateTime? // prisma adapter field
  image             String? // prisma adapter field
  accounts          Account[]
  sessions          Session[]
  firstName         String
  lastName          String
  middleName        String?
  password          String
  email             String                @unique
  role              String // * type constrainted at the backend level.
  company           String?
  branchName        String?
  lastSaleDate      DateTime?
  lastLogin         DateTime?
  currentBalance    Int?
  preferredLanguage String                @default("English")
  licenseId         Int?                  @unique
  // addresses         address[]
  addresses         UserAddress[]
  deliveryAddresses UserDeliveryAddress[]
  orders            Order[]               @relation("CUSTOMER")
  orderCreator    Order[]            @relation("creatorUser")
  pickups           Order[]               @relation("DRIVER")
  currentCart       cart[]                @relation("cartCreator")
  cartCustomer      cart[]                @relation("customer")
  creationDateTime  DateTime              @default(now())
}

model UserAddress {
  id         Int     @id @default(autoincrement())
  userId     String
  address    String
  address2   String?
  address3   String?
  city       String
  state      String
  postalCode Int
  country    String
  cellphone  String?
  telephone  String?
  default    Boolean @default(false)
  user       User    @relation(fields: [userId], references: [id])
}

model UserDeliveryAddress {
  id         Int     @id @default(autoincrement())
  userId     String
  address    String
  address2   String?
  address3   String?
  city       String
  state      String
  postalCode Int
  country    String
  cellphone  String?
  telephone  String?
  default    Boolean @default(false)
  user       User    @relation(fields: [userId], references: [id])
}

model Order {
  id             Int      @unique @default(autoincrement())
  orderId      String @unique @default(uuid())
  customerUserId String // thecustomer who sent the package, so client/shipper
  customer       User     @relation("CUSTOMER", fields: [customerUserId], references: [id])
  creatorUserId  String
  creatorUser    User     @relation("creatorUser", fields: [creatorUserId], references: [id])
  timePlaced     DateTime @default(now()) //UTC TIME 4 hours ahead of EST time // ? TODO change to update from client side event using localtime. so that in the database the time you see is in the same timezone as the pickupTime, which is in gmt (utc+4000)
  // currentBalance Int?
  totalBalancePaid Int?
  orderPayments  orderPayments[]
  statusMessage   String
  status          orderStatus           @relation(fields: [statusMessage], references: [message])
  totalCost       Int?
  paymentStatus   String
  paymentStatuses paymentStatus         @relation(fields: [paymentStatus], references: [status])
  pickupDriverId  String?
  pickupDriver    User?                 @relation(name: "DRIVER", fields: [pickupDriverId], references: [id])
  pickupDate      DateTime?
  pickupTime      String?
  items           OrderItem[]
  shipperAddress  OrderShipperAddress?
  recieverAddress OrderRecieverAddress?
  pickupZoneId      Int?
  pickupZone        pickupZone? @relation(fields: [pickupZoneId], references: [id])
  containerId       Int?
  container         containers? @relation(fields: [containerId], references: [id])
  // stripeCheckoutUrl String?
  // stripeCheckoutId  String?     @unique //need stripe informmation to connect order to relevent stripe checkout session, with this id i can query specific orders when updating with information from stripe checkout
  // stripePaymentIntent String? @unique
  // stripeReceiptUrl    String?
  // ? instead of just ids, going to add the entire items of stripepayments to the database to backup the data
  // DONE TODO: REMOVE, no longer needed, products now kept locally istead of using stripe products
  // stripeCheckout Json? @db.JsonB // stripe checkout.session.completed event object that includes the paymentintent id and stripe checkout Id need to query stripe for the line items, that i add locally from the app to the database because stripe is also getting the line items from the app.
  // stripePaymentIntent Json? @db.JsonB // not needed since checkout object has necessary information
  // orderLocations   orderLocations? @relation(fields: [orderLocationsId], references: [id])
  // orderLocationsId Int?

  @@id([id, customerUserId, creatorUserId], map: "orderPK")
}

model orderPayments {
  id               Int     @id @default(autoincrement())
  orderId          String
  order            Order   @relation(fields: [orderId], references: [orderId], onDelete: Restrict)
  confirmed   Boolean? @default(false)
  paymentType      String // set at checkout //stripe webhooks can change this as necessary
  amountPaid       Int
  receiptImageLink String?
  paymentId        Int?
  stripeCheckoutUrl String?
  stripeCheckoutId  String?     @unique //need stripe informmation to connect order to relevent stripe checkout session, with this id i can query specific orders when updating with information from stripe checkout
  stripePaymentIntent String? @unique
  stripeReceiptUrl    String?
}

// model Route {
//   id Int @id @default(autoincrement())
//   areaCode String
//   orders Order[]
// }
model pickupZone {
  id    Int     @id @default(autoincrement())
  name  String
  code  String
  order Order[]
}

model OrderShipperAddress {
  id         Int     @id @default(autoincrement())
  firstName  String?
  lastName   String?
  orderId    Int     @unique
  order      Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  address    String?
  address2   String?
  address3   String?
  city       String?
  state      String?
  postalCode Int?
  country    String?
  cellphone  String?
  telephone  String?
}

model OrderRecieverAddress {
  id         Int     @id @default(autoincrement())
  // .query("getAddressesFromCart")
  firstName  String?
  lastName   String?
  orderId    Int     @unique
  order      Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  address    String?
  address2   String?
  address3   String?
  city       String?
  state      String?
  postalCode Int?
  country    String?
  cellphone  String?
  telephone  String?
}

model OrderItem {
  id        Int     @id @default(autoincrement())
  orderId   Int
  order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  quantity  Int
  productId BigInt
  product   product @relation(fields: [productId], references: [id])
  // onSiteCreatedProductId BigInt?
  // onSiteCreatedProduct onSiteCreatedProduct? @relation(fields: [onSiteCreatedProductId], references: [id])

}


// TODO driver edits invoice, after driver confirms reciever address and item being shipper. add orderLocations table that tracks the orderItems individally, so 4 boxes of used clothes that show up as
// 4 seperate row of item locations, each delivery package label QR code corresponds to a location entry, this way
// packages in one order are tracked sepearlty, if one goes missing that location shouldnt be updated, and when looking under order status for a confirmed invoice
// it wont appear as deliver in red or something

model orderStatus {
  id      Int     @id @default(autoincrement())
  message String  @unique @default("awaiting pickup")
  order   Order[]
}

model paymentStatus {
  id     Int     @id @default(autoincrement())
  status String  @unique
  order  Order[]
}

model product {
  id        BigInt         @id @default(autoincrement())
  name      String
  price     Int // in USD cents, $50.25 = 5025
  description String?
  orderItem OrderItem[]
  cartItem  cartItem[]
  createdOnPickup Boolean @default(false) // false means it was created by an admin/staff in office, not during a pickup
}

// model productType {
//   id Int @id @default(autoincrement())
//   type String @unique
//   product product[]
// }

// shipping container that are sent on  the boat
model containers {
  id               Int             @id @default(autoincrement())
  statusId         Int
  status           containerStatus @relation(fields: [statusId], references: [id])
  orders           Order[]
  warehouseId      Int
  warehouseDetails warehouse       @relation(fields: [warehouseId], references: [id])
  // location String
  // deliveredDate
  // pickupDate
  // paidFor
  // reachDestination
}

model warehouseSupplies {
  id             Int       @id @default(autoincrement())
  supplyName     String // tape
  inventoryCount Int // 10
  warehouseId    Int // warehouse that supply is located in
  warehouse      warehouse @relation(fields: [warehouseId], references: [id])
  // location String
}

model warehouse {
  id         Int                 @id @default(autoincrement())
  codeName   String // BX, DR
  name       String //bronx, Dominican Republic
  supplies   warehouseSupplies[]
  containers containers[]
  address    String?
  // @@map("warehouseDetails")
}

model containerStatus {
  id        Int          @id @default(autoincrement())
  message   String
  container containers[]
}


// ? maybe make a way to save orders so another admin/staff may takeover the order??
model cart {
  // id              Int                  @default(autoincrement())
  cartId          String               @unique @default(uuid())
  customerId      String
  customer        User                 @relation(fields: [customerId], references: [id], name: "customer")
  creatingUserId  String
  cartCreator     User                 @relation(fields: [creatingUserId], references: [id], name: "cartCreator")
  items           cartItem[]
  // addresses       CartOrderAddresses[]
  shipperAddress  cartShipperAddress?
  recieverAddress cartRecieverAddress?
  totalCost       Int?
  // order addresses saved in cart table before being added to order table
  // current orderForm with addresses

  @@id([creatingUserId, customerId])
}

model cartShipperAddress {
  id         Int     @id @default(autoincrement())
  // .query("getAddressesFromCart")
  firstName  String?
  lastName   String?
  cartId     String  @unique
  cart       cart    @relation(fields: [cartId], references: [cartId], onDelete: Cascade)
  address    String?
  address2   String?
  address3   String?
  city       String?
  state      String?
  postalCode Int?
  country    String?
  cellphone  String?
  telephone  String?
}

model cartRecieverAddress {
  id         Int     @id @default(autoincrement())
  // .query("getAddressesFromCart")
  firstName  String?
  lastName   String?
  cartId     String  @unique
  cart       cart    @relation(fields: [cartId], references: [cartId], onDelete: Cascade)
  address    String?
  address2   String?
  address3   String?
  city       String?
  state      String?
  postalCode Int?
  country    String?
  cellphone  String?
  telephone  String?
}

// model CartOrderAddresses {
//   id         Int     @default(autoincrement())
//   cartId     String
//   // .query("getAddressesFromCart")
//   firstName  String?
//   lastName   String?
//   cart       cart    @relation(fields: [cartId], references: [cartId], onDelete: Cascade)
//   address    String?
//   address2   String?
//   address3   String?
//   city       String?
//   state      String?
//   postalCode Int?
//   country    String?
//   cellphone  String?
//   telephone  String?
//   // default Boolean @default(false)
//   recipient  Boolean @default(false)

//   @@id([cartId, recipient]) //reciever: recipient==true, shipper:recipient==false; address, one form for both addresses caused me to use another varibale mot hadnle the difference between addresses.
// }

model cartItem {
  id        Int     @default(autoincrement())
  cartId    String
  cart      cart    @relation(fields: [cartId], references: [cartId], onDelete: Cascade, onUpdate: Cascade)
  quantity  Int
  productId BigInt
  product   product @relation(fields: [productId], references: [id])
  // onSiteCreatedProductId BigInt?
  // onSiteCreatedProduct onSiteCreatedProduct? @relation(fields: [onSiteCreatedProductId], references: [id])

  @@id([cartId, productId], name: "CartItemId")
}

// model onSiteCreatedProduct {
//   id        BigInt         @id @default(autoincrement())
//   name      String
//   price     Int // in USD cents, $50.25 = 5025
//   orderItem OrderItem[]
//   cartItem  cartItem[]
// }

model StripeEvent {
  id               String   @id @unique
  api_version      String?
  data             Json
  request          Json?
  type             String
  object           String
  account          String?
  created          DateTime
  livemode         Boolean
  pending_webhooks Int
}

//  Next-Auth models used in adapters for database sessions commonly used for Oauth
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// model User {
//   id            String    @id @default(cuid())
//   name          String?
//   email         String?   @unique
//   emailVerified DateTime?
//   image         String?
//   accounts      Account[]
//   sessions      Session[]
// }

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Next-Auth models End //

// model DriverRoutes {
//   id Int @id @default(autoincrement())
//   driverId Int
//   driver User @relation(fields: [driverId], references:[id] )
//   orders Order[]
// }
